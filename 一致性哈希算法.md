# 一致性哈希算法（Consistent Hashing）

## 基本场景

目前有N个缓存服务器（节点）提供服务，如何对各节点进行负载均衡？

使用简单的哈希算法：对节点由0 ~ (N-1)进行编号，对于每个请求关键字key使用 *hash(key) mod N* 得到对应余数i，然后将其分发到编号为i的节点。

此算法问题在于其容错性与扩展性都很差1——后台节点的增删会导致几乎所有的key需要重新映射，大量缓存无法命中，缓存数据需要重新建立（增加一个节点，会有N/(N+1)的缓存数据需要转移至新节点；删除一个节点，会有(N-1)/N的缓存数据需要转移至新节点）。对于系统而言，这通常是不可接受的颠簸。

而在Memcached、Key-Value Store 、Bittorrent DHT、LVS中都采用了Consistent Hashing算法，Consistent Hashing 是分布式系统负载均衡的首选算法。

## 算法简述

一致性哈希算法的基本思想是将服务器节点和缓存对象使用相同的哈希算法映射到同一个由哈希值顺时针方向从小到大排列组成的虚拟圆环上，具体如下：

* 首先按照各节点的哈希值（可以使用ip或主机名等进行哈希）确定其在哈希圆环上的位置
* 然后按照同样的哈希算法得到缓存对象键的哈希值并映射到同一个圆环上，顺时针方向寻得离其最近的节点记为其服务节点

如此，每个节点负责圆环上上一节点到本身的一段圆弧，如果出现某节点a的增删均只影响a到a-1节点间圆弧上的数据，只有a+1节点受到影响。

## 哈希环的偏斜

在服务节点数太少时，容易因为节点分布不均而造成数据倾斜（被缓存的对象大部分集中在某几台少数服务器上），未解决这个问题，一致性哈希算法引入了虚拟节点机制：对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点的复制品（replica），称为虚拟节点（可以在服务器ip或者主机名后面增加编号实现）。增加了节点在圆上分布的均匀性与分散性。

使用虚拟节点后，映射关系就由{缓存对象->节点}变为了{缓存对象->虚拟节点->真实节点}

## 附：分布式缓存系统哈希方案的衡量标准

* 平衡性（Balance）

  哈希的结果应该能够尽可能的分布到所有缓冲中去，使得所有缓冲空间都能够得到利用。

  很多哈希算法都能够满足这一条件。

* 单调性（Monotonicity）

  如果有一些内容已经通过哈希分派到了相应的缓冲中，此时有新的缓冲区加入到系统中，那么哈希的结果应该能够保证原有的已分配的内容可以被映射到新的缓存区中区，但不会被映射到原缓冲集合中其他的缓冲区（即会有部分缓存数据需要由旧节点转移至新节点，但不会有缓存数据需要由原旧节点转移至另一个旧节点）。

  简单的哈希算法往往不能满足单调性的要求——如上述的 *hash(key) mod N* ,当缓冲大小发声变化（由N到M），几乎所有的哈希结果都会产生变化。而一致性哈希算法则满足此条件。

* 分散性（Spread）

  在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。

* 负载（Load）

   负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。

* 平滑性（Smoothness）

   平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。